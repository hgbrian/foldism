<!DOCTYPE html>
<html>
<head>
    <title>Foldism - Protein Structure Prediction</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
        h1 { margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 20px; }
        .panel { background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h2 { margin-top: 0; color: #444; font-size: 1.2em; }
        textarea { width: 100%; height: 150px; font-family: monospace; font-size: 12px; border: 1px solid #ddd; border-radius: 4px; padding: 10px; }
        .methods { display: flex; gap: 15px; margin: 15px 0; flex-wrap: wrap; }
        .methods label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
        button { background: #2563eb; color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; }
        button:hover { background: #1d4ed8; }
        button:disabled { background: #9ca3af; cursor: not-allowed; }
        .progress-container { margin-top: 15px; display: none; }
        .progress-container.active { display: block; }
        .progress-bar { height: 24px; background: #e5e7eb; border-radius: 12px; overflow: hidden; margin-bottom: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #3b82f6, #8b5cf6); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; }
        .log { background: #1e1e1e; color: #d4d4d4; font-family: monospace; font-size: 11px; padding: 10px; border-radius: 4px; height: 150px; overflow-y: auto; margin-top: 10px; }
        .log .info { color: #4fc3f7; }
        .log .success { color: #81c784; }
        .log .error { color: #e57373; }
        #viewer-container { width: 100%; height: 500px; background: #fff; border-radius: 4px; border: 1px solid #ddd; }
        .results { margin-top: 15px; }
        .result-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f9fafb; border-radius: 4px; margin-bottom: 8px; }
        .result-item input[type="checkbox"] { margin-right: 8px; cursor: pointer; }
        .result-item .downloads { display: flex; gap: 8px; }
        .result-item .downloads a { color: #2563eb; text-decoration: none; font-size: 13px; padding: 4px 8px; border: 1px solid #2563eb; border-radius: 4px; }
        .metrics { display: flex; gap: 8px; margin-left: 12px; }
        .metric { font-size: 12px; }
        .metric-label { color: #666; margin-right: 2px; }
        .metric-value { font-weight: 600; }
        .metric-value.good { color: #16a34a; }
        .metric-value.medium { color: #ca8a04; }
        .metric-value.poor { color: #dc2626; }
        .example-link { font-size: 13px; color: #666; margin-top: 10px; }
        .example-link a { color: #2563eb; }
    </style>
</head>
<body>

<div style="display: flex; align-items: flex-end; gap: 3px; margin-bottom: 5px;">
  <svg viewBox="430 200 380 530" xmlns="http://www.w3.org/2000/svg" style="width: 52px; height: 52px; margin-bottom: -8px;">
    <defs>
      <path id="p" d="M548,427c10,-4 30,-12 47,-22c40,-22 85,-45 113,-82c15,-20 18,-55 5,-70c-10,-12 -30,-5 -42,10c-20,25 -25,70 -30,110c-8,65 -15,140 -40,200c-12,30 -35,55 -60,50c-20,-4 -25,-30 -15,-55c12,-30 35,-50 60,-75c45,-40 100,-80 145,-110"/>
      <linearGradient id="g" y2="1">
        <stop offset="0" stop-color="#4ECDC4"/>
        <stop offset="1" stop-color="#96E6A1"/>
      </linearGradient>
    </defs>
    <use href="#p" fill="none" stroke="#000" stroke-width="44" stroke-linecap="round" stroke-linejoin="round"/>
    <use href="#p" fill="none" stroke="url(#g)" stroke-width="32" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
  <h1 style="color: #333; font-size: 2rem; font-weight: 300; letter-spacing: 0.1em; margin: 0;">foldism</h1>
</div>
    <p class="subtitle">Protein structure prediction with Boltz-2, Chai-1, Protenix, Protenix-mini, AlphaFold 2</p>
    <div class="panel">
        <h2>Input Sequence</h2>
        <form id="fold-form">
            <textarea id="fasta-input" name="fasta" placeholder="Paste FASTA sequence here..."></textarea>
            <div class="methods">
                <label><input type="checkbox" name="method" value="chai1" checked> Chai-1</label>
                <label><input type="checkbox" name="method" value="boltz2"> Boltz-2</label>
                <label><input type="checkbox" name="method" value="protenix"> Protenix</label>
                <label><input type="checkbox" name="method" value="protenix-mini"> Protenix-Mini</label>
                <label><input type="checkbox" name="method" value="alphafold2"> AlphaFold 2</label>
            </div>
            <div style="margin: 8px 0; font-size: 13px; color: #666;">
                <label style="cursor:pointer;"><input type="checkbox" id="use-msa" checked style="margin-right: 4px;">Use MSA</label>
                <span style="margin-left: 8px; color: #999;">(slower but higher quality; Boltz-2 and AlphaFold2 always use MSA)</span>
            </div>
            <button type="submit" id="submit-btn">Predict Structure</button>
        </form>
        <div class="progress-container" id="progress-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div id="progress-text">Initializing...</div>
                <div id="elapsed-time" style="font-family: monospace; color: #666;">0:00</div>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="progress-fill">0%</div></div>
            <div class="log" id="log"></div>
        </div>
        <div class="example-link">
            Examples: <span id="examples-list">loading...</span>
            <a href="#" onclick="saveCurrentSequence(); return false;" style="margin-left:8px;color:#16a34a;" title="Save current sequence">[+]</a>
            <span id="undo-btn" style="display:none;"><a href="#" onclick="undoDelete(); return false;" style="margin-left:8px;color:#666;" title="Undo delete">[undo]</a></span>
        </div>
    </div>
    <div class="panel">
        <h2>Results</h2>
        <div class="results" id="results"></div>
        <div id="viewer-container"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/ngl@2.0.0-dev.37/dist/ngl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3/dist/jszip.min.js"></script>
    <script>
        let stage = null;
        let loadedComponents = {};
        const methodColors = {'Boltz-2': '#3B82F6', 'Chai-1': '#EF4444', 'Protenix': '#22C55E', 'Protenix-Mini': '#A855F7', 'AlphaFold2': '#F59E0B'};

        document.addEventListener("DOMContentLoaded", function () {
            stage = new NGL.Stage("viewer-container", { backgroundColor: "white" });
            window.addEventListener("resize", () => stage.handleResize(), false);
            loadExamples();
        });

        const defaultExamples = {
            'Insulin': '>Insulin\nGIVEQCCTSICSLYQLENYCN\n>InsulinB\nFVNQHLCGSHLVEALYLVCGERGFFYTPKT',
            'GFP': '>GFP\nMSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTLTYGVQCFSRYPDHMKQHDFFKSAMPEGYVQERTIFFKDDGNYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNYNSHNVYIMADKQKNGIKVNFKIRHNIEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMVLLEFVTAAGITLGMDELYK',
            'Lysozyme': '>Lysozyme\nKVFGRCELAAAMKRHGLDNYRGYSLGNWVCAAKFESNFNTQATNRNTDGSTDYGILQINSRWWCNDGRTPGSRNLCNIPCSALLSSDITASVNCAKKIVSDGNGMNAWVAWRNRCKGTDVQAWIRGCRL'
        };

        function getExamples() {
            try { return JSON.parse(localStorage.getItem('foldism-examples') || '{}'); }
            catch (e) { return {}; }
        }

        function saveExamples(examples) {
            localStorage.setItem('foldism-examples', JSON.stringify(examples));
        }

        function loadExamples() {
            const container = document.getElementById('examples-list');
            let html = Object.keys(defaultExamples).map(name =>
                `<a href="#" onclick="loadExample('${name}'); return false;">${name}</a>`
            ).join(' | ');
            const userExamples = getExamples();
            const userNames = Object.keys(userExamples).sort();
            if (userNames.length > 0) {
                html += ' | ' + userNames.map(name =>
                    `<a href="#" onclick="loadExample('${name}'); return false;">${name}</a><a href="#" onclick="deleteExample('${name}'); return false;" style="color:#999;text-decoration:none;" title="Delete ${name}">[×]</a>`
                ).join(' ');
            }
            container.innerHTML = html;
        }

        function loadExample(name) {
            if (defaultExamples[name]) {
                document.getElementById('fasta-input').value = defaultExamples[name];
                return;
            }
            const examples = getExamples();
            if (examples[name]) document.getElementById('fasta-input').value = examples[name];
        }

        function saveCurrentSequence() {
            const fasta = document.getElementById('fasta-input').value.trim();
            if (!fasta) { alert('No sequence to save'); return; }
            const match = fasta.match(/^>([^\n\r]+)/);
            let name = match ? match[1].split(/\s/)[0].split('|')[0].substring(0, 30) : 'sequence';
            name = name.replace(/[^a-zA-Z0-9_-]/g, '_');
            const examples = getExamples();
            examples[name] = fasta;
            saveExamples(examples);
            loadExamples();
            document.getElementById('undo-btn').style.display = 'none';
        }

        let lastDeleted = null;
        function deleteExample(name) {
            const examples = getExamples();
            if (examples[name]) lastDeleted = { name, fasta: examples[name] };
            delete examples[name];
            saveExamples(examples);
            loadExamples();
            document.getElementById('undo-btn').style.display = 'inline';
        }

        function undoDelete() {
            if (!lastDeleted) return;
            const examples = getExamples();
            examples[lastDeleted.name] = lastDeleted.fasta;
            saveExamples(examples);
            lastDeleted = null;
            document.getElementById('undo-btn').style.display = 'none';
            loadExamples();
        }

        // Track running methods for progressive dots
        const runningMethods = {};

        // Method configurations for log sections
        const methodConfigs = {
            'boltz2': { name: 'Boltz-2', prefix: '[Boltz]' },
            'chai1': { name: 'Chai-1', prefix: '[Chai-1]' },
            'protenix': { name: 'Protenix', prefix: '[Protenix]' },
            'protenix-mini': { name: 'Protenix-Mini', prefix: '[Protenix-Mini]' },
            'alphafold2': { name: 'AlphaFold2', prefix: '[AlphaFold2]' }
        };

        function createLogSection(methodKey) {
            const config = methodConfigs[methodKey];
            if (!config) return;

            const containerId = methodKey + '-log-container';
            const detailsId = methodKey + '-details';

            // Don't create if already exists
            if (document.getElementById(detailsId)) return;

            const logEl = document.getElementById('log');
            const container = document.createElement('div');
            container.id = containerId;
            container.style.cssText = 'margin: 4px 0; padding: 6px 8px; background: rgba(255, 255, 255, 0.05); border-left: 3px solid rgba(255, 255, 255, 0.2); border-radius: 2px;';

            const header = document.createElement('div');
            header.style.cssText = 'cursor: pointer; font-size: 12px; color: rgba(255, 255, 255, 0.7); user-select: none;';
            header.innerHTML = `▶ ${config.name} detailed logs <span style="opacity: 0.5;">(click to expand)</span>`;

            const detailsEl = document.createElement('div');
            detailsEl.id = detailsId;
            detailsEl.style.cssText = 'display: none; max-height: 200px; overflow-y: auto; margin-top: 6px; padding: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; font-size: 11px; line-height: 1.4;';

            let isExpanded = false;
            header.onclick = () => {
                isExpanded = !isExpanded;
                detailsEl.style.display = isExpanded ? 'block' : 'none';
                header.innerHTML = `${isExpanded ? '▼' : '▶'} ${config.name} detailed logs <span style="opacity: 0.5;">(click to ${isExpanded ? 'collapse' : 'expand'})</span>`;
            };

            container.appendChild(header);
            container.appendChild(detailsEl);

            // Insert after the main method log line if it exists, otherwise append
            const methodLogLine = document.getElementById('log-' + methodKey);
            if (methodLogLine) {
                methodLogLine.parentNode.insertBefore(container, methodLogLine.nextSibling);
            } else {
                logEl.appendChild(container);
            }
        }

        function log(msg, cls = '', methodKey = null) {
            const logEl = document.getElementById('log');

            // Special handling for detailed logs from any method
            const detailedLogPrefixes = {
                '[Boltz]': { key: 'boltz2', name: 'Boltz-2' },
                '[Chai-1]': { key: 'chai1', name: 'Chai-1' },
                '[Protenix]': { key: 'protenix', name: 'Protenix' },
                '[Protenix-Mini]': { key: 'protenix-mini', name: 'Protenix-Mini' },
                '[AlphaFold2]': { key: 'alphafold2', name: 'AlphaFold2' }
            };

            for (const [prefix, config] of Object.entries(detailedLogPrefixes)) {
                if (msg.startsWith(prefix + ' ')) {
                    const containerId = config.key + '-log-container';
                    const detailsId = config.key + '-details';
                    let detailsEl = document.getElementById(detailsId);

                    if (!detailsEl) {
                        // Create expandable log section
                        const container = document.createElement('div');
                        container.id = containerId;
                        container.style.cssText = 'margin: 4px 0; padding: 6px 8px; background: rgba(255, 255, 255, 0.05); border-left: 3px solid rgba(255, 255, 255, 0.2); border-radius: 2px;';

                        const header = document.createElement('div');
                        header.style.cssText = 'cursor: pointer; font-size: 12px; color: rgba(255, 255, 255, 0.7); user-select: none;';
                        header.innerHTML = `▶ ${config.name} detailed logs <span style="opacity: 0.5;">(click to expand)</span>`;

                        detailsEl = document.createElement('div');
                        detailsEl.id = detailsId;
                        detailsEl.style.cssText = 'display: none; max-height: 200px; overflow-y: auto; margin-top: 6px; padding: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; font-size: 11px; line-height: 1.4;';

                        let isExpanded = false;
                        header.onclick = () => {
                            isExpanded = !isExpanded;
                            detailsEl.style.display = isExpanded ? 'block' : 'none';
                            header.innerHTML = `${isExpanded ? '▼' : '▶'} ${config.name} detailed logs <span style="opacity: 0.5;">(click to ${isExpanded ? 'collapse' : 'expand'})</span>`;
                        };

                        container.appendChild(header);
                        container.appendChild(detailsEl);

                        // Insert after the main method log line if it exists, otherwise append
                        const methodLogLine = document.getElementById('log-' + config.key);
                        if (methodLogLine) {
                            methodLogLine.parentNode.insertBefore(container, methodLogLine.nextSibling);
                        } else {
                            logEl.appendChild(container);
                        }
                    }

                    // Add log line to details
                    const logLine = document.createElement('div');
                    logLine.textContent = msg.replace(prefix + ' ', '');
                    logLine.style.cssText = 'color: rgba(255, 255, 255, 0.65); margin: 1px 0; font-family: monospace;';
                    detailsEl.appendChild(logLine);
                    detailsEl.scrollTop = detailsEl.scrollHeight;
                    return;
                }
            }

            const line = document.createElement('div');
            line.className = cls;
            line.textContent = msg;
            if (methodKey) {
                line.id = 'log-' + methodKey;
                runningMethods[methodKey] = true;
            }
            logEl.appendChild(line);
            // Create expandable log section AFTER adding line to DOM so insertion works
            if (methodKey) {
                createLogSection(methodKey);
            }
            logEl.scrollTop = logEl.scrollHeight;
        }

        function markMethodComplete(methodKey, success = true) {
            delete runningMethods[methodKey];
            const el = document.getElementById('log-' + methodKey);
            if (el) {
                // Replace "Running X..." with "Completed X" or "Failed X"
                const status = success ? 'Completed' : 'Failed';
                el.textContent = el.textContent.replace(/^Running/, status).replace(/\.+$/, '');
                el.className = success ? 'success' : 'error';
            }
        }

        function formatMetric(value, label) {
            if (value === undefined || value === null) return '';
            // Handle array of values (e.g., multi-chain ipTM)
            if (Array.isArray(value)) {
                const formatted = value.map(v => {
                    let numVal = typeof v === 'number' ? v : parseFloat(v);
                    if (isNaN(numVal)) return null;
                    if (numVal > 1) numVal /= 100;
                    return numVal.toFixed(2);
                }).filter(v => v !== null);
                if (formatted.length === 0) return '';
                const avgVal = value.reduce((a, b) => a + (typeof b === 'number' ? b : parseFloat(b)), 0) / value.length;
                const colorClass = avgVal >= 0.8 ? 'good' : avgVal >= 0.5 ? 'medium' : 'poor';
                return `<span class="metric"><span class="metric-label">${label}:</span><span class="metric-value ${colorClass}">${formatted.join(', ')}</span></span>`;
            }
            let numVal = typeof value === 'number' ? value : parseFloat(value);
            if (isNaN(numVal)) return '';
            // Normalize to 0-1 scale (AlphaFold2 reports pLDDT as 0-100)
            if (numVal > 1) numVal /= 100;
            const displayVal = numVal.toFixed(2);
            const colorClass = numVal >= 0.8 ? 'good' : numVal >= 0.5 ? 'medium' : 'poor';
            return `<span class="metric"><span class="metric-label">${label}:</span><span class="metric-value ${colorClass}">${displayVal}</span></span>`;
        }

        function countChains(fasta) {
            // Count number of chains (headers starting with >) in FASTA
            return (fasta.match(/^>/gm) || []).length;
        }

        function extractMetrics(scores, method) {
            if (!scores) return {};
            const metrics = {};
            if (method === 'Boltz-2') {
                if (scores.confidence_score !== undefined) metrics.confidence = scores.confidence_score;
                if (scores.ptm !== undefined) metrics.ptm = scores.ptm;
                // pLDDT: per-residue array, compute mean
                if (scores.plddt !== undefined) {
                    metrics.plddt = Array.isArray(scores.plddt)
                        ? scores.plddt.reduce((a, b) => a + b, 0) / scores.plddt.length
                        : scores.plddt;
                }
                // Extract per-chain ipTM from chain 0's perspective (A vs B, A vs C, etc)
                if (scores.pair_chains_iptm && scores.pair_chains_iptm['0']) {
                    const chain0 = scores.pair_chains_iptm['0'];
                    const otherChains = Object.keys(chain0).filter(k => k !== '0').sort();
                    if (otherChains.length > 0) {
                        metrics.iptm = otherChains.map(k => chain0[k]);
                    }
                } else if (scores.iptm !== undefined) {
                    metrics.iptm = scores.iptm;
                }
            } else if (method === 'Chai-1') {
                if (scores.aggregate_score) metrics.aggregate = Array.isArray(scores.aggregate_score) ? scores.aggregate_score[0] : scores.aggregate_score;
                if (scores.ptm) metrics.ptm = Array.isArray(scores.ptm) ? scores.ptm[0] : scores.ptm;
                // pLDDT: per-residue array, compute mean
                if (scores.plddt !== undefined) {
                    const plddt = Array.isArray(scores.plddt) && Array.isArray(scores.plddt[0]) ? scores.plddt[0] : scores.plddt;
                    metrics.plddt = Array.isArray(plddt)
                        ? plddt.reduce((a, b) => a + b, 0) / plddt.length
                        : plddt;
                }
                // Extract per-chain ipTM from chain 0's perspective (A vs B, A vs C, etc)
                // per_chain_pair_iptm is [num_chains, num_chains] - row 0 has chain 0 vs all others
                if (scores.per_chain_pair_iptm && Array.isArray(scores.per_chain_pair_iptm)) {
                    const matrix = scores.per_chain_pair_iptm;
                    // Handle nested array structure [[[]]] from npz
                    const row0 = Array.isArray(matrix[0]) && Array.isArray(matrix[0][0]) ? matrix[0][0] : matrix[0];
                    if (row0 && row0.length > 1) {
                        metrics.iptm = row0.slice(1);  // Skip diagonal (0 vs 0), get 0 vs 1, 0 vs 2, etc
                    }
                } else if (scores.iptm) {
                    metrics.iptm = Array.isArray(scores.iptm) ? scores.iptm[0] : scores.iptm;
                }
            } else if (method === 'Protenix' || method === 'Protenix-Mini') {
                if (scores.ranking_score !== undefined) metrics.ranking = scores.ranking_score;
                if (scores.ptm !== undefined) metrics.ptm = scores.ptm;
                // Protenix may have pair_iptm similar to Boltz
                if (scores.pair_iptm && typeof scores.pair_iptm === 'object') {
                    const chain0 = scores.pair_iptm['0'] || scores.pair_iptm[0];
                    if (chain0) {
                        const otherChains = Object.keys(chain0).filter(k => k !== '0' && k !== 0).sort();
                        if (otherChains.length > 0) {
                            metrics.iptm = otherChains.map(k => chain0[k]);
                        }
                    }
                } else if (scores.iptm !== undefined) {
                    metrics.iptm = scores.iptm;
                }
            } else if (method === 'AlphaFold2') {
                // ranking_debug.json format: {plddts: {model_1: 85.2}, order: [...]}
                if (scores.plddts) {
                    const plddtVals = Object.values(scores.plddts);
                    if (plddtVals.length > 0) metrics.plddt = plddtVals[0];
                }
                // Individual model scores: {plddt: 85.2} or {plddt: [per-residue array]}
                if (scores.plddt !== undefined) {
                    metrics.plddt = Array.isArray(scores.plddt)
                        ? scores.plddt.reduce((a, b) => a + b, 0) / scores.plddt.length
                        : scores.plddt;
                }
                // ptm can be dict {model_1: 0.9} or direct value
                if (scores.ptm !== undefined) {
                    if (typeof scores.ptm === 'object') {
                        const ptmVals = Object.values(scores.ptm);
                        if (ptmVals.length > 0) metrics.ptm = ptmVals[0];
                    } else metrics.ptm = scores.ptm;
                }
                if (scores.iptm !== undefined) {
                    if (typeof scores.iptm === 'object' && !Array.isArray(scores.iptm)) {
                        const iptmVals = Object.values(scores.iptm);
                        metrics.iptm = iptmVals.length > 1 ? iptmVals : iptmVals[0];
                    } else {
                        metrics.iptm = scores.iptm;
                    }
                }
            }
            return metrics;
        }

        function buildMetricsHTML(metrics, numChains) {
            if (!metrics || Object.keys(metrics).length === 0) return '';
            let html = '';
            if (metrics.plddt !== undefined) html += formatMetric(metrics.plddt, 'pLDDT');
            // ipTM only meaningful for multi-chain complexes
            if (numChains > 1) {
                if (metrics.iptm !== undefined) html += formatMetric(metrics.iptm, 'ipTM');
            }
            if (metrics.ptm !== undefined) html += formatMetric(metrics.ptm, 'pTM');
            if (metrics.confidence !== undefined) html += formatMetric(metrics.confidence, 'conf');
            if (metrics.ranking !== undefined) html += formatMetric(metrics.ranking, 'rank');
            if (metrics.aggregate !== undefined) html += formatMetric(metrics.aggregate, 'agg');
            return html ? `<span class="metrics">${html}</span>` : '';
        }

        async function loadStructure(url, format, methodName) {
            try {
                const ext = (format === 'pdb') ? 'pdb' : 'mmcif';
                console.log(`Loading ${methodName} as ${ext}...`);
                const comp = await stage.loadFile(url, { ext: ext, defaultRepresentation: false });
                console.log(`${methodName} loaded, atoms:`, comp.structure?.atomCount || 'unknown');
                comp.addRepresentation("cartoon", { color: methodColors[methodName] || '#888', opacity: 0.9 });
                if (Object.keys(loadedComponents).length === 0) {
                    comp.autoView();
                    console.log(`${methodName}: autoView called (first structure)`);
                }
                loadedComponents[methodName] = comp;
                console.log(`${methodName} added to viewport`);
                // Auto-center on all structures after each load
                stage.autoView();
            } catch (e) { console.error(`Failed to load ${methodName}:`, e); }
        }

        function toggleStructureVisibility(methodName, visible) {
            if (loadedComponents[methodName]) {
                loadedComponents[methodName].setVisibility(visible);
            }
        }

        let downloadAllPending = null;  // Guard against concurrent calls
        async function updateDownloadAllButton(resultsData, inputHash, totalMethods) {
            if (resultsData.length === 0) return;

            // Wait for any pending update to finish
            if (downloadAllPending) await downloadAllPending;

            const updatePromise = (async () => {
                const resultsEl = document.getElementById('results');

                // Create zip from current results
                const zip = new JSZip();
                for (const r of resultsData) {
                    const methodSlug = r.method.toLowerCase().replace(/[^a-z0-9]/g, '_');
                    const structureBytes = atob(r.structure);
                    zip.file(`${methodSlug}-${inputHash}.${r.ext}`, structureBytes);

                    if (r.all_files) {
                        const allFilesBytes = atob(r.all_files);
                        const allFilesBlob = new Blob([new Uint8Array([...allFilesBytes].map(c => c.charCodeAt(0)))]);
                        const allFilesZip = await JSZip.loadAsync(allFilesBlob);
                        const folder = zip.folder(methodSlug);
                        for (const [path, fileObj] of Object.entries(allFilesZip.files)) {
                            if (!fileObj.dir) {
                                const content = await fileObj.async('uint8array');
                                folder.file(path, content);
                            }
                        }
                    }
                }

                const blob = await zip.generateAsync({type: 'blob'});
                const zipUrl = URL.createObjectURL(blob);

                // Check for existing element AFTER async work (in case another call created it)
                let downloadAllRow = document.getElementById('download-all-row');
                if (!downloadAllRow) {
                    downloadAllRow = document.createElement('div');
                    downloadAllRow.id = 'download-all-row';
                    downloadAllRow.className = 'result-item';
                    downloadAllRow.style.background = '#e0f2fe';
                    resultsEl.insertBefore(downloadAllRow, resultsEl.firstChild);
                }

                const countText = resultsData.length === totalMethods ? 'all' : `${resultsData.length}/${totalMethods}`;
                downloadAllRow.innerHTML = `<span style="font-weight:500;">Download All (${countText})</span><span class="downloads"><a href="${zipUrl}" download="foldism-${inputHash}.zip">Combined ZIP</a></span>`;
            })();

            downloadAllPending = updatePromise;
            await updatePromise;
            downloadAllPending = null;
        }

        // Re-enable submit button when textarea is edited after a run
        document.getElementById('fasta-input').addEventListener('input', () => {
            const submitBtn = document.getElementById('submit-btn');
            if (submitBtn.disabled) {
                submitBtn.disabled = false;
            }
        });

        document.getElementById('fold-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const fasta = document.getElementById('fasta-input').value.trim();
            if (!fasta) { alert('Please enter a sequence'); return; }
            const methods = Array.from(document.querySelectorAll('input[name="method"]:checked')).map(el => el.value);
            if (methods.length === 0) { alert('Please select at least one method'); return; }

            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const submitBtn = document.getElementById('submit-btn');
            const logEl = document.getElementById('log');
            const resultsEl = document.getElementById('results');

            progressContainer.classList.add('active');
            submitBtn.disabled = true;
            logEl.innerHTML = '';
            resultsEl.innerHTML = '';
            if (stage) { stage.removeAllComponents(); loadedComponents = {}; }

            // Estimate total time based on methods and protein size
            const seqLength = fasta.replace(/>[^\n]*\n/g, '').replace(/\s/g, '').length;
            const useMsa = document.getElementById('use-msa').checked;
            const baseTimePerMethod = useMsa ? 180 : 60;  // seconds
            const sizeMultiplier = Math.max(1, seqLength / 200);
            const estimatedTotal = baseTimePerMethod * sizeMultiplier;  // Methods run in parallel
            const numChains = countChains(fasta);

            // Smooth progress state
            let currentProgress = 0;
            let targetProgress = 0;
            let completedMethods = 0;
            let isDone = false;

            // Start timer
            const elapsedEl = document.getElementById('elapsed-time');
            const startTime = Date.now();
            const timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                elapsedEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            }, 1000);

            // Smooth progress animation with asymptotic behavior
            const progressInterval = setInterval(() => {
                if (isDone) {
                    currentProgress = 100;
                } else {
                    const elapsed = (Date.now() - startTime) / 1000;
                    // Base progress from time elapsed (asymptotic to ~80%)
                    // Time constant = estimatedTotal means ~63% at estimatedTotal seconds
                    const timeProgress = 80 * (1 - Math.exp(-elapsed / estimatedTotal));
                    // Bonus from completed methods
                    const methodProgress = (completedMethods / methods.length) * 15;
                    targetProgress = Math.min(95, timeProgress + methodProgress);
                    // Smooth interpolation toward target
                    currentProgress += (targetProgress - currentProgress) * 0.1;
                }
                const displayProgress = Math.round(currentProgress);
                progressFill.style.width = displayProgress + '%';
                progressFill.textContent = displayProgress + '%';
                if (isDone) clearInterval(progressInterval);
            }, 100);

            log('Starting prediction...', 'info');

            // Generate 6-char hash of input for filenames
            async function hashFasta(str) {
                const encoder = new TextEncoder();
                const data = encoder.encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 6);
            }
            const inputHash = await hashFasta(fasta);

            function base64ToBlob(b64, mime) {
                const bytes = atob(b64);
                const arr = new Uint8Array(bytes.length);
                for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
                return URL.createObjectURL(new Blob([arr], { type: mime }));
            }

            async function createPartialZip(resultsData, inputHash) {
                const zip = new JSZip();

                for (const r of resultsData) {
                    const methodSlug = r.method.toLowerCase().replace(/[^a-z0-9]/g, '_');
                    const structureBytes = atob(r.structure);
                    zip.file(`${methodSlug}-${inputHash}.${r.ext}`, structureBytes);

                    if (r.all_files) {
                        const allFilesBytes = atob(r.all_files);
                        const allFilesBlob = new Blob([new Uint8Array([...allFilesBytes].map(c => c.charCodeAt(0)))]);
                        const allFilesZip = await JSZip.loadAsync(allFilesBlob);
                        const folder = zip.folder(methodSlug);
                        for (const [path, fileObj] of Object.entries(allFilesZip.files)) {
                            if (!fileObj.dir) {
                                const content = await fileObj.async('uint8array');
                                folder.file(path, content);
                            }
                        }
                    }
                }

                const blob = await zip.generateAsync({type: 'blob'});
                return URL.createObjectURL(blob);
            }

            const formData = new FormData();
            formData.append('fasta', fasta);
            methods.forEach(m => formData.append('method', m));
            formData.append('use_msa', useMsa ? 'true' : 'false');

            try {
                // Submit job and get job_id
                const response = await fetch('/fold', { method: 'POST', body: formData });
                const { job_id, error: submitError } = await response.json();
                if (submitError) { log('Error: ' + submitError, 'error'); return; }

                // Track displayed logs and results to avoid duplicates
                let displayedLogs = 0;
                let displayedResults = new Set();
                let completedResultsData = [];
                let pollCount = 0;

                // Poll for status
                function getPollDelay() {
                    if (pollCount < 3) return 1000;   // First 3 polls: 1s
                    return 3000;                       // After that: 3s
                }

                async function poll() {
                    pollCount++;
                    try {
                        const statusRes = await fetch('/status/' + job_id);
                        const data = await statusRes.json();

                        if (data.error) {
                            log('Error: ' + data.error, 'error');
                            isDone = true;
                            clearInterval(timerInterval);
                            clearInterval(progressInterval);
                            submitBtn.disabled = false;
                            return;
                        }

                        // Update progress and status
                        if (data.status) progressText.textContent = data.status;
                        if (data.progress) targetProgress = data.progress;

                        // Display new logs
                        if (data.logs && data.logs.length > displayedLogs) {
                            for (let i = displayedLogs; i < data.logs.length; i++) {
                                const l = data.logs[i];
                                if (l.msg) log(l.msg, l.cls || '', l.method_key || null);
                                if (l.method_complete) markMethodComplete(l.method_complete, l.cls !== 'error');
                            }
                            displayedLogs = data.logs.length;
                        }

                        // Handle method completion/error from top-level data
                        if (data.method_complete) {
                            markMethodComplete(data.method_complete, !data.method_error);
                        }

                        // Display new results
                        if (data.results) {
                            for (const result of data.results) {
                                if (displayedResults.has(result.method_key)) continue;
                                displayedResults.add(result.method_key);
                                completedMethods++;

                                const resultData = result.data;
                                const colorStr = methodColors[result.method] || '#888';

                                const structureMime = resultData.ext === 'pdb' ? 'chemical/x-pdb' : 'chemical/x-cif';
                                const structureUrl = base64ToBlob(resultData.structure, structureMime);
                                let downloadUrl = structureUrl, downloadExt = resultData.ext;
                                if (resultData.original_cif) {
                                    downloadUrl = base64ToBlob(resultData.original_cif, 'chemical/x-cif');
                                    downloadExt = 'cif';
                                }

                                const methodSlug = result.method.toLowerCase().replace(/[^a-z0-9]/g, '');
                                let downloads = `<a href="${downloadUrl}" download="${methodSlug}-${inputHash}.${downloadExt}">Structure</a>`;
                                if (resultData.zip) {
                                    const zipUrl = base64ToBlob(resultData.zip, 'application/zip');
                                    downloads += `<a href="${zipUrl}" download="${methodSlug}-${inputHash}_all.zip">All Files</a>`;
                                }

                                // Parse scores and build metrics HTML
                                let metricsHTML = '';
                                if (resultData.scores) {
                                    try {
                                        const scoresBytes = atob(resultData.scores);
                                        const scores = JSON.parse(scoresBytes);
                                        const metrics = extractMetrics(scores, result.method);
                                        metricsHTML = buildMetricsHTML(metrics, numChains);
                                    } catch (e) { console.error('Failed to parse scores:', e); }
                                }

                                const item = document.createElement('div');
                                item.className = 'result-item';
                                item.innerHTML = `<span style="display:flex;align-items:center;"><input type="checkbox" checked onchange="toggleStructureVisibility('${result.method}', this.checked)"><span style="display:inline-block;width:12px;height:12px;background:${colorStr};border-radius:2px;margin-right:6px;"></span>${result.method}${metricsHTML}</span><span class="downloads">${downloads}</span>`;
                                resultsEl.appendChild(item);

                                // Load structure asynchronously (don't block on it)
                                loadStructure(structureUrl, result.format, result.method).catch(e =>
                                    console.error(`Failed to load structure for ${result.method}:`, e)
                                );

                                // Track completed results for partial download
                                completedResultsData.push({
                                    method: result.method,
                                    method_key: result.method_key,
                                    structure: resultData.original_cif || resultData.structure,
                                    ext: resultData.original_cif ? 'cif' : resultData.ext,
                                    all_files: resultData.zip
                                });

                                // Update "Download All" button after each result
                                updateDownloadAllButton(completedResultsData, inputHash, methods.length);
                            }
                        }

                        // Check if done
                        if (data.done) {
                            isDone = true;
                            currentProgress = 100;
                            progressFill.style.width = '100%';
                            progressFill.textContent = '100%';
                            progressText.textContent = 'Complete!';
                            log('All predictions complete!', 'success');

                            clearInterval(timerInterval);
                            clearInterval(progressInterval);
                            submitBtn.disabled = false;
                        }
                    } catch (pollError) {
                        console.error('Poll error:', pollError);
                    }
                    if (!isDone) setTimeout(poll, getPollDelay());
                }
                setTimeout(poll, 500);  // First poll after 500ms
            } catch (error) { log('Error: ' + error.message, 'error'); clearInterval(timerInterval); clearInterval(progressInterval); submitBtn.disabled = false; }
        });
    </script>
</body>
</html>
